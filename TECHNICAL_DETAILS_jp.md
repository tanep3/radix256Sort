# 技術解説: radix256Sort

[English](TECHNICAL_DETAILS.md) | [READMEに戻る](README_jp.md)

`radix256Sort` は、32ビット整数 (`u32`) に特化した、超高速かつ安定な Radix Sort (基数ソート) の実装です。
汎用性をあえて捨て、CPUキャッシュ効率とアロケーションの最小化に「全振り」することで、標準のソート (`std::slice::sort` / TimSort) を凌駕するパフォーマンスを実現しています。

## 発明点・特徴

本アルゴリズムの設計における主要な発明点と特徴は以下の6点です。

### 1. 256基数・4パス固定の明確な定義
可変基数や汎用的な設計を排除し、`u32` を 8bit ずつ 4回で処理する構成に固定しました。
これにより、ループ回数がコンパイル時に確定し、分岐予測の失敗を最小限に抑え、コンパイラによる強力な最適化（ループ展開など）を誘発します。

### 2. Counting配列のローカル固定化
各パスで使用するヒストグラム（カウント用配列）を、ヒープではなくスタック上の固定長配列 (`[usize; 256]`) として確保します。
これにより、動的なメモリアロケーション（`malloc`/`free`）のオーバーヘッドをゼロにし、L1キャッシュへのヒット率を劇的に向上させています。

### 3. ダブルバッファによる完全安定ソート
LSD (Least Significant Digit) Radix Sort の要件である「安定性」を保証するため、入力配列 (`from`) と同サイズのバッファ (`to`) を用意し、交互に書き込むダブルバッファ方式を採用しています。
ポインタの交換 (`swap`) だけでバッファを切り替えるため、データのコピーコストを最小限に抑えつつ、数学的に証明された安定性を維持しています。

### 4. 固定長 Prefix Sum
各バケツの書き込み開始位置を計算する累積和（Prefix Sum）も、256要素の固定長ループで行います。
このサイズは確実に L1 キャッシュに収まるため、メモリアクセスのレイテンシが隠蔽され、極めて高速に実行されます。一般的な汎用Radix Sortではここがボトルネックになりがちですが、本実装では固定長化により解消しています。

### 5. Rustの所有権モデルへの適合 (Safe Rust)
`unsafe` ブロックを一切使用せず、Rustの所有権システムと借用チェッカーに完全に適合する形で実装されています。
`Vec` やスライスの所有権を適切に管理し、メモリ安全性（Bounds Checkなど）をコンパイラに保証させつつ、イテレータの最適化により Bounds Check のコストを極小化しています。これは標準ライブラリへの採用を見据えた場合、極めて高い価値を持ちます。

### 6. PyO3による「生配列高速化」の実証
Pythonバインディングにおいて、PyO3を用いてRustの高速性をそのままPythonの世界に持ち込んでいます。
特に、Pythonの `list` や `numpy` 配列の内部データを直接扱うことで、インタープリタのオーバーヘッドを回避し、純粋なネイティブコードとしての速度を提供します。これは「RustでPythonを高速化する」典型的な成功例として、教育的価値も高いものです。

## アルゴリズムの動作原理 (LSD Radix Sort)

1.  **準備**: 入力配列と同じサイズのバッファを確保します。
2.  **ループ**: 以下の処理を 4回 (shift = 0, 8, 16, 24) 繰り返します。
    *   **Count**: 入力配列を走査し、現在の桁 (8bit) の値ごとの出現回数を数えます。
    *   **Accumulate**: 出現回数の累積和を計算し、各バケツの書き込み開始位置を決定します。
    *   **Reorder**: 入力配列を再走査し、計算した位置に従ってバッファに値を書き込みます。
    *   **Swap**: 入力配列とバッファの役割を入れ替えます。
3.  **完了**: 4回目のパスが終了した時点で、データはソートされた状態で元の配列（またはバッファ）に存在します。本実装では偶数回のパスを行うため、結果は必ず元の配列格納領域に戻ってきます。
